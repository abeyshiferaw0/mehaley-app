import 'package:elf_play/config/enums.dart';
import 'package:elf_play/data/data_providers/home_data_provider.dart';
import 'package:elf_play/data/models/album.dart';
import 'package:elf_play/data/models/api_response/home_page_data.dart';
import 'package:elf_play/data/models/category.dart';
import 'package:elf_play/data/models/group.dart';
import 'package:elf_play/data/models/home_shortcut/album_shortcut.dart';
import 'package:elf_play/data/models/home_shortcut/category_shortcut.dart';
import 'package:elf_play/data/models/home_shortcut/playlist_shortcut.dart';
import 'package:elf_play/data/models/home_shortcut/shortcut_data.dart';
import 'package:elf_play/data/models/playlist.dart';
import 'package:elf_play/data/models/song.dart';
import 'package:elf_play/data/models/sync/song_sync_played_from.dart';
import 'package:elf_play/util/download_util.dart';
import 'package:enum_to_string/enum_to_string.dart';

class HomeDataRepository {
  //INIT PROVIDER FOR API CALL
  final HomeDataProvider homeDataProvider;

  const HomeDataRepository({required this.homeDataProvider});

  Future<HomePageData> getHomeData(AppCacheStrategy appCacheStrategy) async {
    final List<Song> recentlyPlayed;
    final List<Category> categories;
    final List<Group> adminGroups;
    final List<Group> autogeneratedGroups;
    final List<Album> featuredAlbums;
    final ShortcutData shortcutData;
    final List<Playlist> featuredPlaylist;
    final List<Song> featuredSongs;

    var response = await homeDataProvider.getRawHomeData(appCacheStrategy);

    //GET RECENTLY PLAYED FROM HIVE
    recentlyPlayed = (response.data['recently_played'] as List)
        .map((song) => Song.fromMap(song["song"]))
        .toList();

    //PARSE CATEGORIES
    categories = (response.data['categories'] as List)
        .map((category) => Category.fromMap(category))
        .toList();

    //PARSE GROUPS FROM ADMIN
    adminGroups = (response.data['admin_groups'] as List)
        .map((group) => Group.fromMap(group, true))
        .toList();

    //PARSE AUTO GENERATED GROUPS
    autogeneratedGroups = (response.data['autogenerated_groups'] as List)
        .map((group) => Group.fromMap(group, false))
        .toList();

    //PARSE FEATURED ALBUMS
    featuredAlbums = (response.data['featured_album'] as List)
        .map((album) => Album.fromMap(album))
        .toList();

    //PARSE FEATURED PLAYLISTS
    featuredPlaylist = (response.data['featured_playlist'] as List)
        .map((playlist) => Playlist.fromMap(playlist))
        .toList();

    //PARSE FEATURED SONGS
    featuredSongs = (response.data['featured_songs'] as List)
        .map((song) => Song.fromMap(song))
        .toList();

    //PARSE FEATURED SONGS
    shortcutData = await parseShortCutData(response.data);

    HomePageData homePageData = HomePageData(
      recentlyPlayed: recentlyPlayed,
      categories: categories,
      adminGroups: adminGroups,
      response: response,
      featuredAlbums: featuredAlbums,
      featuredPlaylist: featuredPlaylist,
      shortcutData: shortcutData,
      autogeneratedGroups: autogeneratedGroups,
      featuredSongs: featuredSongs,
    );

    return homePageData;
  }

  cancelDio() {
    homeDataProvider.cancel();
  }

  Future<ShortcutData> parseShortCutData(data) async {
    final int purchasedCount;
    final int downloadCount;
    final List<dynamic> shortcuts;

    purchasedCount = data['short_cut_data']['purchased_count'] as int;
    downloadCount = await DownloadUtil().getNumberOfDownloads();
    shortcuts = (data['short_cut_data']['short_cuts'] as List).map((item) {
      if (item["played_from"] ==
          EnumToString.convertToString(SongSyncPlayedFrom.PLAYLIST_DETAIL)) {
        return PlaylistShortcut.fromMap(item["item"]);
      } else if (item["played_from"] ==
          EnumToString.convertToString(SongSyncPlayedFrom.ALBUM_DETAIL)) {
        return AlbumShortcut.fromMap(item["item"]);
      } else if (item["played_from"] ==
          EnumToString.convertToString(SongSyncPlayedFrom.CATEGORY_DETAIL)) {
        return CategoryShortcut.fromMap(item["item"]);
      } else {
        throw "short cut type not valid";
      }
    }).toList();

    return ShortcutData(
      purchasedCount: purchasedCount,
      downloadCount: downloadCount,
      shortcuts: shortcuts,
    );
  }
}
